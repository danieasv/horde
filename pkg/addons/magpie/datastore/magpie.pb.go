// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.24.0
// 	protoc        v3.5.1
// source: magpie.proto

//
// Copyright 2020 Telenor Digital AS
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

package datastore

import (
	context "context"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// This is a compile-time assertion that a sufficiently up-to-date version
// of the legacy proto package is being used.
const _ = proto.ProtoPackageIsVersion4

// DataMessage is both the input and the output from the data store. The
// sequence numbers aren't message identifiers. They are just counters for
// messages to keep track of acknowledgements.
type DataMessage struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Sequence int64 `protobuf:"varint,1,opt,name=sequence,proto3" json:"sequence,omitempty"` // Message sequence number. Not an identifier but just a
	// sequence number assigned by the sender.
	CollectionId string `protobuf:"bytes,2,opt,name=collectionId,proto3" json:"collectionId,omitempty"` // Collection identifier
	DeviceId     string `protobuf:"bytes,3,opt,name=deviceId,proto3" json:"deviceId,omitempty"`         // Device identifier
	Created      int64  `protobuf:"varint,4,opt,name=created,proto3" json:"created,omitempty"`          // Timestamp (in ns) for data creation. Set by client.
	Metadata     []byte `protobuf:"bytes,5,opt,name=metadata,proto3" json:"metadata,omitempty"`         // Message metadata
	Payload      []byte `protobuf:"bytes,6,opt,name=payload,proto3" json:"payload,omitempty"`           // Binary payload
}

func (x *DataMessage) Reset() {
	*x = DataMessage{}
	if protoimpl.UnsafeEnabled {
		mi := &file_magpie_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *DataMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DataMessage) ProtoMessage() {}

func (x *DataMessage) ProtoReflect() protoreflect.Message {
	mi := &file_magpie_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DataMessage.ProtoReflect.Descriptor instead.
func (*DataMessage) Descriptor() ([]byte, []int) {
	return file_magpie_proto_rawDescGZIP(), []int{0}
}

func (x *DataMessage) GetSequence() int64 {
	if x != nil {
		return x.Sequence
	}
	return 0
}

func (x *DataMessage) GetCollectionId() string {
	if x != nil {
		return x.CollectionId
	}
	return ""
}

func (x *DataMessage) GetDeviceId() string {
	if x != nil {
		return x.DeviceId
	}
	return ""
}

func (x *DataMessage) GetCreated() int64 {
	if x != nil {
		return x.Created
	}
	return 0
}

func (x *DataMessage) GetMetadata() []byte {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *DataMessage) GetPayload() []byte {
	if x != nil {
		return x.Payload
	}
	return nil
}

// DataFilter is the filtering parameters for data. collectionId is
type DataFilter struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	CollectionId string `protobuf:"bytes,1,opt,name=collectionId,proto3" json:"collectionId,omitempty"` // Collection identifier (required)
	DeviceId     string `protobuf:"bytes,2,opt,name=deviceId,proto3" json:"deviceId,omitempty"`         // Device identifer (blank = ignore)
	From         int64  `protobuf:"varint,3,opt,name=from,proto3" json:"from,omitempty"`                // Time interval start (<=0 = ignore)
	To           int64  `protobuf:"varint,4,opt,name=to,proto3" json:"to,omitempty"`                    // Time interval stop (<=0 = ignore)
	Limit        int32  `protobuf:"varint,5,opt,name=limit,proto3" json:"limit,omitempty"`              // Limit number of returned elements
}

func (x *DataFilter) Reset() {
	*x = DataFilter{}
	if protoimpl.UnsafeEnabled {
		mi := &file_magpie_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *DataFilter) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DataFilter) ProtoMessage() {}

func (x *DataFilter) ProtoReflect() protoreflect.Message {
	mi := &file_magpie_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DataFilter.ProtoReflect.Descriptor instead.
func (*DataFilter) Descriptor() ([]byte, []int) {
	return file_magpie_proto_rawDescGZIP(), []int{1}
}

func (x *DataFilter) GetCollectionId() string {
	if x != nil {
		return x.CollectionId
	}
	return ""
}

func (x *DataFilter) GetDeviceId() string {
	if x != nil {
		return x.DeviceId
	}
	return ""
}

func (x *DataFilter) GetFrom() int64 {
	if x != nil {
		return x.From
	}
	return 0
}

func (x *DataFilter) GetTo() int64 {
	if x != nil {
		return x.To
	}
	return 0
}

func (x *DataFilter) GetLimit() int32 {
	if x != nil {
		return x.Limit
	}
	return 0
}

// Receipt messages are sent by the data store to acknowledge receiption of
// messages.
type Receipt struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Sequence int64 `protobuf:"varint,1,opt,name=sequence,proto3" json:"sequence,omitempty"`
}

func (x *Receipt) Reset() {
	*x = Receipt{}
	if protoimpl.UnsafeEnabled {
		mi := &file_magpie_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Receipt) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Receipt) ProtoMessage() {}

func (x *Receipt) ProtoReflect() protoreflect.Message {
	mi := &file_magpie_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Receipt.ProtoReflect.Descriptor instead.
func (*Receipt) Descriptor() ([]byte, []int) {
	return file_magpie_proto_rawDescGZIP(), []int{2}
}

func (x *Receipt) GetSequence() int64 {
	if x != nil {
		return x.Sequence
	}
	return 0
}

type DataMetrics struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	CollectionId   string `protobuf:"bytes,1,opt,name=collectionId,proto3" json:"collectionId,omitempty"`      // Collection identifier
	DeviceId       string `protobuf:"bytes,2,opt,name=deviceId,proto3" json:"deviceId,omitempty"`              // Device identifier
	MessageCount   int64  `protobuf:"varint,3,opt,name=messageCount,proto3" json:"messageCount,omitempty"`     // Number of data messages found
	FirstDataPoint int64  `protobuf:"varint,4,opt,name=firstDataPoint,proto3" json:"firstDataPoint,omitempty"` // Time for first data message
	LastDataPoint  int64  `protobuf:"varint,5,opt,name=lastDataPoint,proto3" json:"lastDataPoint,omitempty"`   // Time for last data message
}

func (x *DataMetrics) Reset() {
	*x = DataMetrics{}
	if protoimpl.UnsafeEnabled {
		mi := &file_magpie_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *DataMetrics) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DataMetrics) ProtoMessage() {}

func (x *DataMetrics) ProtoReflect() protoreflect.Message {
	mi := &file_magpie_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DataMetrics.ProtoReflect.Descriptor instead.
func (*DataMetrics) Descriptor() ([]byte, []int) {
	return file_magpie_proto_rawDescGZIP(), []int{3}
}

func (x *DataMetrics) GetCollectionId() string {
	if x != nil {
		return x.CollectionId
	}
	return ""
}

func (x *DataMetrics) GetDeviceId() string {
	if x != nil {
		return x.DeviceId
	}
	return ""
}

func (x *DataMetrics) GetMessageCount() int64 {
	if x != nil {
		return x.MessageCount
	}
	return 0
}

func (x *DataMetrics) GetFirstDataPoint() int64 {
	if x != nil {
		return x.FirstDataPoint
	}
	return 0
}

func (x *DataMetrics) GetLastDataPoint() int64 {
	if x != nil {
		return x.LastDataPoint
	}
	return 0
}

var File_magpie_proto protoreflect.FileDescriptor

var file_magpie_proto_rawDesc = []byte{
	0x0a, 0x0c, 0x6d, 0x61, 0x67, 0x70, 0x69, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x09,
	0x64, 0x61, 0x74, 0x61, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x22, 0xb9, 0x01, 0x0a, 0x0b, 0x44, 0x61,
	0x74, 0x61, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x12, 0x1a, 0x0a, 0x08, 0x73, 0x65, 0x71,
	0x75, 0x65, 0x6e, 0x63, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x08, 0x73, 0x65, 0x71,
	0x75, 0x65, 0x6e, 0x63, 0x65, 0x12, 0x22, 0x0a, 0x0c, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74,
	0x69, 0x6f, 0x6e, 0x49, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x63, 0x6f, 0x6c,
	0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x64, 0x12, 0x1a, 0x0a, 0x08, 0x64, 0x65, 0x76,
	0x69, 0x63, 0x65, 0x49, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x64, 0x65, 0x76,
	0x69, 0x63, 0x65, 0x49, 0x64, 0x12, 0x18, 0x0a, 0x07, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64,
	0x18, 0x04, 0x20, 0x01, 0x28, 0x03, 0x52, 0x07, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x12,
	0x1a, 0x0a, 0x08, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x18, 0x05, 0x20, 0x01, 0x28,
	0x0c, 0x52, 0x08, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x12, 0x18, 0x0a, 0x07, 0x70,
	0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x07, 0x70, 0x61,
	0x79, 0x6c, 0x6f, 0x61, 0x64, 0x22, 0x86, 0x01, 0x0a, 0x0a, 0x44, 0x61, 0x74, 0x61, 0x46, 0x69,
	0x6c, 0x74, 0x65, 0x72, 0x12, 0x22, 0x0a, 0x0c, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69,
	0x6f, 0x6e, 0x49, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x63, 0x6f, 0x6c, 0x6c,
	0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x64, 0x12, 0x1a, 0x0a, 0x08, 0x64, 0x65, 0x76, 0x69,
	0x63, 0x65, 0x49, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x64, 0x65, 0x76, 0x69,
	0x63, 0x65, 0x49, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x66, 0x72, 0x6f, 0x6d, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x03, 0x52, 0x04, 0x66, 0x72, 0x6f, 0x6d, 0x12, 0x0e, 0x0a, 0x02, 0x74, 0x6f, 0x18, 0x04,
	0x20, 0x01, 0x28, 0x03, 0x52, 0x02, 0x74, 0x6f, 0x12, 0x14, 0x0a, 0x05, 0x6c, 0x69, 0x6d, 0x69,
	0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x05, 0x52, 0x05, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x22, 0x25,
	0x0a, 0x07, 0x52, 0x65, 0x63, 0x65, 0x69, 0x70, 0x74, 0x12, 0x1a, 0x0a, 0x08, 0x73, 0x65, 0x71,
	0x75, 0x65, 0x6e, 0x63, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x08, 0x73, 0x65, 0x71,
	0x75, 0x65, 0x6e, 0x63, 0x65, 0x22, 0xbf, 0x01, 0x0a, 0x0b, 0x44, 0x61, 0x74, 0x61, 0x4d, 0x65,
	0x74, 0x72, 0x69, 0x63, 0x73, 0x12, 0x22, 0x0a, 0x0c, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74,
	0x69, 0x6f, 0x6e, 0x49, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x63, 0x6f, 0x6c,
	0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x64, 0x12, 0x1a, 0x0a, 0x08, 0x64, 0x65, 0x76,
	0x69, 0x63, 0x65, 0x49, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x64, 0x65, 0x76,
	0x69, 0x63, 0x65, 0x49, 0x64, 0x12, 0x22, 0x0a, 0x0c, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65,
	0x43, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0c, 0x6d, 0x65, 0x73,
	0x73, 0x61, 0x67, 0x65, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x26, 0x0a, 0x0e, 0x66, 0x69, 0x72,
	0x73, 0x74, 0x44, 0x61, 0x74, 0x61, 0x50, 0x6f, 0x69, 0x6e, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28,
	0x03, 0x52, 0x0e, 0x66, 0x69, 0x72, 0x73, 0x74, 0x44, 0x61, 0x74, 0x61, 0x50, 0x6f, 0x69, 0x6e,
	0x74, 0x12, 0x24, 0x0a, 0x0d, 0x6c, 0x61, 0x73, 0x74, 0x44, 0x61, 0x74, 0x61, 0x50, 0x6f, 0x69,
	0x6e, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0d, 0x6c, 0x61, 0x73, 0x74, 0x44, 0x61,
	0x74, 0x61, 0x50, 0x6f, 0x69, 0x6e, 0x74, 0x32, 0xfc, 0x01, 0x0a, 0x09, 0x44, 0x61, 0x74, 0x61,
	0x53, 0x74, 0x6f, 0x72, 0x65, 0x12, 0x39, 0x0a, 0x07, 0x50, 0x75, 0x74, 0x44, 0x61, 0x74, 0x61,
	0x12, 0x16, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x2e, 0x44, 0x61, 0x74,
	0x61, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x1a, 0x12, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x73,
	0x74, 0x6f, 0x72, 0x65, 0x2e, 0x52, 0x65, 0x63, 0x65, 0x69, 0x70, 0x74, 0x28, 0x01, 0x30, 0x01,
	0x12, 0x3a, 0x0a, 0x07, 0x47, 0x65, 0x74, 0x44, 0x61, 0x74, 0x61, 0x12, 0x15, 0x2e, 0x64, 0x61,
	0x74, 0x61, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x2e, 0x44, 0x61, 0x74, 0x61, 0x46, 0x69, 0x6c, 0x74,
	0x65, 0x72, 0x1a, 0x16, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x2e, 0x44,
	0x61, 0x74, 0x61, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x30, 0x01, 0x12, 0x3f, 0x0a, 0x0e,
	0x47, 0x65, 0x74, 0x44, 0x61, 0x74, 0x61, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x12, 0x15,
	0x2e, 0x64, 0x61, 0x74, 0x61, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x2e, 0x44, 0x61, 0x74, 0x61, 0x46,
	0x69, 0x6c, 0x74, 0x65, 0x72, 0x1a, 0x16, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x73, 0x74, 0x6f, 0x72,
	0x65, 0x2e, 0x44, 0x61, 0x74, 0x61, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x12, 0x37, 0x0a,
	0x09, 0x53, 0x74, 0x6f, 0x72, 0x65, 0x44, 0x61, 0x74, 0x61, 0x12, 0x16, 0x2e, 0x64, 0x61, 0x74,
	0x61, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x2e, 0x44, 0x61, 0x74, 0x61, 0x4d, 0x65, 0x73, 0x73, 0x61,
	0x67, 0x65, 0x1a, 0x12, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x2e, 0x52,
	0x65, 0x63, 0x65, 0x69, 0x70, 0x74, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_magpie_proto_rawDescOnce sync.Once
	file_magpie_proto_rawDescData = file_magpie_proto_rawDesc
)

func file_magpie_proto_rawDescGZIP() []byte {
	file_magpie_proto_rawDescOnce.Do(func() {
		file_magpie_proto_rawDescData = protoimpl.X.CompressGZIP(file_magpie_proto_rawDescData)
	})
	return file_magpie_proto_rawDescData
}

var file_magpie_proto_msgTypes = make([]protoimpl.MessageInfo, 4)
var file_magpie_proto_goTypes = []interface{}{
	(*DataMessage)(nil), // 0: datastore.DataMessage
	(*DataFilter)(nil),  // 1: datastore.DataFilter
	(*Receipt)(nil),     // 2: datastore.Receipt
	(*DataMetrics)(nil), // 3: datastore.DataMetrics
}
var file_magpie_proto_depIdxs = []int32{
	0, // 0: datastore.DataStore.PutData:input_type -> datastore.DataMessage
	1, // 1: datastore.DataStore.GetData:input_type -> datastore.DataFilter
	1, // 2: datastore.DataStore.GetDataMetrics:input_type -> datastore.DataFilter
	0, // 3: datastore.DataStore.StoreData:input_type -> datastore.DataMessage
	2, // 4: datastore.DataStore.PutData:output_type -> datastore.Receipt
	0, // 5: datastore.DataStore.GetData:output_type -> datastore.DataMessage
	3, // 6: datastore.DataStore.GetDataMetrics:output_type -> datastore.DataMetrics
	2, // 7: datastore.DataStore.StoreData:output_type -> datastore.Receipt
	4, // [4:8] is the sub-list for method output_type
	0, // [0:4] is the sub-list for method input_type
	0, // [0:0] is the sub-list for extension type_name
	0, // [0:0] is the sub-list for extension extendee
	0, // [0:0] is the sub-list for field type_name
}

func init() { file_magpie_proto_init() }
func file_magpie_proto_init() {
	if File_magpie_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_magpie_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*DataMessage); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_magpie_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*DataFilter); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_magpie_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Receipt); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_magpie_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*DataMetrics); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_magpie_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   4,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_magpie_proto_goTypes,
		DependencyIndexes: file_magpie_proto_depIdxs,
		MessageInfos:      file_magpie_proto_msgTypes,
	}.Build()
	File_magpie_proto = out.File
	file_magpie_proto_rawDesc = nil
	file_magpie_proto_goTypes = nil
	file_magpie_proto_depIdxs = nil
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// DataStoreClient is the client API for DataStore service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type DataStoreClient interface {
	// PutData stores messages. Messages are acknowledged when they are written
	// to the underlying data store (whatever that may be).
	PutData(ctx context.Context, opts ...grpc.CallOption) (DataStore_PutDataClient, error)
	// GetData returns data from either a collection (if just collection ID is
	// specified) or a particular device (if both collection ID and device ID is
	// supplied)
	GetData(ctx context.Context, in *DataFilter, opts ...grpc.CallOption) (DataStore_GetDataClient, error)
	// GetDataMetrics returns metrics on data stored. Filtering works similar to
	// the GetData method
	GetDataMetrics(ctx context.Context, in *DataFilter, opts ...grpc.CallOption) (*DataMetrics, error)
	// StoreData is a simpler version of the PutData interface. It's not as
	// performant but easier to implement.
	StoreData(ctx context.Context, in *DataMessage, opts ...grpc.CallOption) (*Receipt, error)
}

type dataStoreClient struct {
	cc grpc.ClientConnInterface
}

func NewDataStoreClient(cc grpc.ClientConnInterface) DataStoreClient {
	return &dataStoreClient{cc}
}

func (c *dataStoreClient) PutData(ctx context.Context, opts ...grpc.CallOption) (DataStore_PutDataClient, error) {
	stream, err := c.cc.NewStream(ctx, &_DataStore_serviceDesc.Streams[0], "/datastore.DataStore/PutData", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataStorePutDataClient{stream}
	return x, nil
}

type DataStore_PutDataClient interface {
	Send(*DataMessage) error
	Recv() (*Receipt, error)
	grpc.ClientStream
}

type dataStorePutDataClient struct {
	grpc.ClientStream
}

func (x *dataStorePutDataClient) Send(m *DataMessage) error {
	return x.ClientStream.SendMsg(m)
}

func (x *dataStorePutDataClient) Recv() (*Receipt, error) {
	m := new(Receipt)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataStoreClient) GetData(ctx context.Context, in *DataFilter, opts ...grpc.CallOption) (DataStore_GetDataClient, error) {
	stream, err := c.cc.NewStream(ctx, &_DataStore_serviceDesc.Streams[1], "/datastore.DataStore/GetData", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataStoreGetDataClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DataStore_GetDataClient interface {
	Recv() (*DataMessage, error)
	grpc.ClientStream
}

type dataStoreGetDataClient struct {
	grpc.ClientStream
}

func (x *dataStoreGetDataClient) Recv() (*DataMessage, error) {
	m := new(DataMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataStoreClient) GetDataMetrics(ctx context.Context, in *DataFilter, opts ...grpc.CallOption) (*DataMetrics, error) {
	out := new(DataMetrics)
	err := c.cc.Invoke(ctx, "/datastore.DataStore/GetDataMetrics", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataStoreClient) StoreData(ctx context.Context, in *DataMessage, opts ...grpc.CallOption) (*Receipt, error) {
	out := new(Receipt)
	err := c.cc.Invoke(ctx, "/datastore.DataStore/StoreData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DataStoreServer is the server API for DataStore service.
type DataStoreServer interface {
	// PutData stores messages. Messages are acknowledged when they are written
	// to the underlying data store (whatever that may be).
	PutData(DataStore_PutDataServer) error
	// GetData returns data from either a collection (if just collection ID is
	// specified) or a particular device (if both collection ID and device ID is
	// supplied)
	GetData(*DataFilter, DataStore_GetDataServer) error
	// GetDataMetrics returns metrics on data stored. Filtering works similar to
	// the GetData method
	GetDataMetrics(context.Context, *DataFilter) (*DataMetrics, error)
	// StoreData is a simpler version of the PutData interface. It's not as
	// performant but easier to implement.
	StoreData(context.Context, *DataMessage) (*Receipt, error)
}

// UnimplementedDataStoreServer can be embedded to have forward compatible implementations.
type UnimplementedDataStoreServer struct {
}

func (*UnimplementedDataStoreServer) PutData(DataStore_PutDataServer) error {
	return status.Errorf(codes.Unimplemented, "method PutData not implemented")
}
func (*UnimplementedDataStoreServer) GetData(*DataFilter, DataStore_GetDataServer) error {
	return status.Errorf(codes.Unimplemented, "method GetData not implemented")
}
func (*UnimplementedDataStoreServer) GetDataMetrics(context.Context, *DataFilter) (*DataMetrics, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDataMetrics not implemented")
}
func (*UnimplementedDataStoreServer) StoreData(context.Context, *DataMessage) (*Receipt, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StoreData not implemented")
}

func RegisterDataStoreServer(s *grpc.Server, srv DataStoreServer) {
	s.RegisterService(&_DataStore_serviceDesc, srv)
}

func _DataStore_PutData_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(DataStoreServer).PutData(&dataStorePutDataServer{stream})
}

type DataStore_PutDataServer interface {
	Send(*Receipt) error
	Recv() (*DataMessage, error)
	grpc.ServerStream
}

type dataStorePutDataServer struct {
	grpc.ServerStream
}

func (x *dataStorePutDataServer) Send(m *Receipt) error {
	return x.ServerStream.SendMsg(m)
}

func (x *dataStorePutDataServer) Recv() (*DataMessage, error) {
	m := new(DataMessage)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _DataStore_GetData_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DataFilter)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DataStoreServer).GetData(m, &dataStoreGetDataServer{stream})
}

type DataStore_GetDataServer interface {
	Send(*DataMessage) error
	grpc.ServerStream
}

type dataStoreGetDataServer struct {
	grpc.ServerStream
}

func (x *dataStoreGetDataServer) Send(m *DataMessage) error {
	return x.ServerStream.SendMsg(m)
}

func _DataStore_GetDataMetrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DataFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataStoreServer).GetDataMetrics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/datastore.DataStore/GetDataMetrics",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataStoreServer).GetDataMetrics(ctx, req.(*DataFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataStore_StoreData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DataMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataStoreServer).StoreData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/datastore.DataStore/StoreData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataStoreServer).StoreData(ctx, req.(*DataMessage))
	}
	return interceptor(ctx, in, info, handler)
}

var _DataStore_serviceDesc = grpc.ServiceDesc{
	ServiceName: "datastore.DataStore",
	HandlerType: (*DataStoreServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetDataMetrics",
			Handler:    _DataStore_GetDataMetrics_Handler,
		},
		{
			MethodName: "StoreData",
			Handler:    _DataStore_StoreData_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "PutData",
			Handler:       _DataStore_PutData_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "GetData",
			Handler:       _DataStore_GetData_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "magpie.proto",
}
